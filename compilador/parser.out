Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT
    LBRACKET
    RBRACKET

Grammar

Rule 0     S' -> program
Rule 1     n_seen_type -> <empty>
Rule 2     n_open_new_scope -> <empty>
Rule 3     n_close_scope -> <empty>
Rule 4     empty -> <empty>
Rule 5     program -> program_aux codeblock
Rule 6     program_aux -> IDK
Rule 7     program_aux -> OWO
Rule 8     type -> INT_TYPE n_seen_type
Rule 9     type -> STRING_TYPE n_seen_type
Rule 10    type -> DOUBLE_TYPE n_seen_type
Rule 11    type -> FLOAT_TYPE n_seen_type
Rule 12    type -> BOOL_TYPE n_seen_type
Rule 13    logic_operator -> GREATERTHAN
Rule 14    logic_operator -> LESSTHAN
Rule 15    logic_operator -> EQUALEQUAL
Rule 16    logic_operator -> LESSTHANOREQUAL
Rule 17    logic_operator -> GREATERTHANOREQUAL
Rule 18    logic_operator -> NOTEQUAL
Rule 19    arithmetic_operator -> PLUS
Rule 20    arithmetic_operator -> MINUS
Rule 21    arithmetic_operator -> TIMES
Rule 22    arithmetic_operator -> DIVIDE
Rule 23    arithmetic_operator -> MODULUS
Rule 24    literal -> FLOAT
Rule 25    literal -> INT
Rule 26    literal -> STRING
Rule 27    function_type -> type
Rule 28    function_type -> VOID
Rule 29    function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
Rule 30    function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS
Rule 31    parameter_list -> empty
Rule 32    parameter_list -> parameter
Rule 33    parameter_list -> parameter COMMA parameter_list
Rule 34    parameter -> type NAME n_name_assign
Rule 35    parameter -> assign
Rule 36    expression -> exp
Rule 37    expression -> exp logic_operator exp
Rule 38    exp -> termino
Rule 39    exp -> termino PLUS exp
Rule 40    exp -> termino MINUS exp
Rule 41    termino -> factor
Rule 42    termino -> factor TIMES termino
Rule 43    termino -> factor DIVIDE termino
Rule 44    factor -> LPARENTHESIS expression RPARENTHESIS
Rule 45    factor -> PLUS value
Rule 46    factor -> MINUS value
Rule 47    factor -> value
Rule 48    value -> function_call
Rule 49    value -> literal
Rule 50    value -> NAME
Rule 51    assign -> type NAME n_name_assign EQUAL expression
Rule 52    assign -> NAME n_name_assign EQUAL expression
Rule 53    n_name_assign -> <empty>
Rule 54    statement -> statement_aux SEMICOLON
Rule 55    statement_aux -> assign
Rule 56    statement_aux -> function_call
Rule 57    codeblock -> empty
Rule 58    codeblock -> codeblock_aux codeblock
Rule 59    codeblock_aux -> statement
Rule 60    codeblock_aux -> function_definition
Rule 61    codeblock_aux -> condition_if
Rule 62    codeblock_aux -> loop
Rule 63    loop -> forloop
Rule 64    loop -> whileloop
Rule 65    whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
Rule 66    forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
Rule 67    condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
Rule 68    condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope
Rule 69    condition_else -> empty

Terminals, with rules where they appear

BOOL_TYPE            : 12
COMMA                : 33
DIVIDE               : 22 43
DOT                  : 
DOUBLEDOT            : 29 66 66
DOUBLE_TYPE          : 10
ELSE                 : 68
EQUAL                : 51 52
EQUALEQUAL           : 15
FLOAT                : 24
FLOAT_TYPE           : 11
FOR                  : 66
FUNCTION             : 29
GREATERTHAN          : 13
GREATERTHANOREQUAL   : 17
IDK                  : 6
IF                   : 67
INT                  : 25
INT_TYPE             : 8
LBRACKET             : 
LCURLY               : 29 65 66 67 68
LESSTHAN             : 14
LESSTHANOREQUAL      : 16
LPARENTHESIS         : 30 44 65 66 67
MINUS                : 20 40 46
MODULUS              : 23
NAME                 : 29 30 34 50 51 52
NOTEQUAL             : 18
OWO                  : 7
PLUS                 : 19 39 45
RBRACKET             : 
RCURLY               : 29 65 66 67 68
RPARENTHESIS         : 30 44 65 66 67
SEMICOLON            : 54
STRING               : 26
STRING_TYPE          : 9
TIMES                : 21 42
VOID                 : 28
WHILE                : 65
error                : 

Nonterminals, with rules where they appear

arithmetic_operator  : 
assign               : 35 55 66 66
codeblock            : 5 29 58 65 66 67 68
codeblock_aux        : 58
condition_else       : 67
condition_if         : 61
empty                : 31 57 69
exp                  : 36 37 37 39 40
expression           : 44 51 52 65 66 67
factor               : 41 42 43
forloop              : 63
function_call        : 48 56
function_definition  : 60
function_type        : 29
literal              : 49
logic_operator       : 37
loop                 : 62
n_close_scope        : 29 65 66 67 68
n_name_assign        : 34 51 52
n_open_new_scope     : 29 65 66 67 68
n_seen_type          : 8 9 10 11 12
parameter            : 32 33
parameter_list       : 29 30 33
program              : 0
program_aux          : 5
statement            : 59
statement_aux        : 54
termino              : 38 39 40 42 43
type                 : 27 34 51
value                : 45 46 47
whileloop            : 64

Parsing method: LALR

state 0

    (0) S' -> . program
    (5) program -> . program_aux codeblock
    (6) program_aux -> . IDK
    (7) program_aux -> . OWO

    IDK             shift and go to state 3
    OWO             shift and go to state 4

    program                        shift and go to state 1
    program_aux                    shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (5) program -> program_aux . codeblock
    (57) codeblock -> . empty
    (58) codeblock -> . codeblock_aux codeblock
    (4) empty -> .
    (59) codeblock_aux -> . statement
    (60) codeblock_aux -> . function_definition
    (61) codeblock_aux -> . condition_if
    (62) codeblock_aux -> . loop
    (54) statement -> . statement_aux SEMICOLON
    (29) function_definition -> . FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (67) condition_if -> . IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (63) loop -> . forloop
    (64) loop -> . whileloop
    (55) statement_aux -> . assign
    (56) statement_aux -> . function_call
    (66) forloop -> . FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (65) whileloop -> . WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    $end            reduce using rule 4 (empty -> .)
    FUNCTION        shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    NAME            shift and go to state 14
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    codeblock                      shift and go to state 5
    empty                          shift and go to state 6
    codeblock_aux                  shift and go to state 7
    statement                      shift and go to state 8
    function_definition            shift and go to state 9
    condition_if                   shift and go to state 10
    loop                           shift and go to state 11
    statement_aux                  shift and go to state 12
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assign                         shift and go to state 18
    function_call                  shift and go to state 19
    type                           shift and go to state 22

state 3

    (6) program_aux -> IDK .

    FUNCTION        reduce using rule 6 (program_aux -> IDK .)
    IF              reduce using rule 6 (program_aux -> IDK .)
    FOR             reduce using rule 6 (program_aux -> IDK .)
    WHILE           reduce using rule 6 (program_aux -> IDK .)
    NAME            reduce using rule 6 (program_aux -> IDK .)
    INT_TYPE        reduce using rule 6 (program_aux -> IDK .)
    STRING_TYPE     reduce using rule 6 (program_aux -> IDK .)
    DOUBLE_TYPE     reduce using rule 6 (program_aux -> IDK .)
    FLOAT_TYPE      reduce using rule 6 (program_aux -> IDK .)
    BOOL_TYPE       reduce using rule 6 (program_aux -> IDK .)
    $end            reduce using rule 6 (program_aux -> IDK .)


state 4

    (7) program_aux -> OWO .

    FUNCTION        reduce using rule 7 (program_aux -> OWO .)
    IF              reduce using rule 7 (program_aux -> OWO .)
    FOR             reduce using rule 7 (program_aux -> OWO .)
    WHILE           reduce using rule 7 (program_aux -> OWO .)
    NAME            reduce using rule 7 (program_aux -> OWO .)
    INT_TYPE        reduce using rule 7 (program_aux -> OWO .)
    STRING_TYPE     reduce using rule 7 (program_aux -> OWO .)
    DOUBLE_TYPE     reduce using rule 7 (program_aux -> OWO .)
    FLOAT_TYPE      reduce using rule 7 (program_aux -> OWO .)
    BOOL_TYPE       reduce using rule 7 (program_aux -> OWO .)
    $end            reduce using rule 7 (program_aux -> OWO .)


state 5

    (5) program -> program_aux codeblock .

    $end            reduce using rule 5 (program -> program_aux codeblock .)


state 6

    (57) codeblock -> empty .

    $end            reduce using rule 57 (codeblock -> empty .)
    RCURLY          reduce using rule 57 (codeblock -> empty .)


state 7

    (58) codeblock -> codeblock_aux . codeblock
    (57) codeblock -> . empty
    (58) codeblock -> . codeblock_aux codeblock
    (4) empty -> .
    (59) codeblock_aux -> . statement
    (60) codeblock_aux -> . function_definition
    (61) codeblock_aux -> . condition_if
    (62) codeblock_aux -> . loop
    (54) statement -> . statement_aux SEMICOLON
    (29) function_definition -> . FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (67) condition_if -> . IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (63) loop -> . forloop
    (64) loop -> . whileloop
    (55) statement_aux -> . assign
    (56) statement_aux -> . function_call
    (66) forloop -> . FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (65) whileloop -> . WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    $end            reduce using rule 4 (empty -> .)
    RCURLY          reduce using rule 4 (empty -> .)
    FUNCTION        shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    NAME            shift and go to state 14
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    codeblock_aux                  shift and go to state 7
    codeblock                      shift and go to state 28
    empty                          shift and go to state 6
    statement                      shift and go to state 8
    function_definition            shift and go to state 9
    condition_if                   shift and go to state 10
    loop                           shift and go to state 11
    statement_aux                  shift and go to state 12
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assign                         shift and go to state 18
    function_call                  shift and go to state 19
    type                           shift and go to state 22

state 8

    (59) codeblock_aux -> statement .

    FUNCTION        reduce using rule 59 (codeblock_aux -> statement .)
    IF              reduce using rule 59 (codeblock_aux -> statement .)
    FOR             reduce using rule 59 (codeblock_aux -> statement .)
    WHILE           reduce using rule 59 (codeblock_aux -> statement .)
    NAME            reduce using rule 59 (codeblock_aux -> statement .)
    INT_TYPE        reduce using rule 59 (codeblock_aux -> statement .)
    STRING_TYPE     reduce using rule 59 (codeblock_aux -> statement .)
    DOUBLE_TYPE     reduce using rule 59 (codeblock_aux -> statement .)
    FLOAT_TYPE      reduce using rule 59 (codeblock_aux -> statement .)
    BOOL_TYPE       reduce using rule 59 (codeblock_aux -> statement .)
    $end            reduce using rule 59 (codeblock_aux -> statement .)
    RCURLY          reduce using rule 59 (codeblock_aux -> statement .)


state 9

    (60) codeblock_aux -> function_definition .

    FUNCTION        reduce using rule 60 (codeblock_aux -> function_definition .)
    IF              reduce using rule 60 (codeblock_aux -> function_definition .)
    FOR             reduce using rule 60 (codeblock_aux -> function_definition .)
    WHILE           reduce using rule 60 (codeblock_aux -> function_definition .)
    NAME            reduce using rule 60 (codeblock_aux -> function_definition .)
    INT_TYPE        reduce using rule 60 (codeblock_aux -> function_definition .)
    STRING_TYPE     reduce using rule 60 (codeblock_aux -> function_definition .)
    DOUBLE_TYPE     reduce using rule 60 (codeblock_aux -> function_definition .)
    FLOAT_TYPE      reduce using rule 60 (codeblock_aux -> function_definition .)
    BOOL_TYPE       reduce using rule 60 (codeblock_aux -> function_definition .)
    $end            reduce using rule 60 (codeblock_aux -> function_definition .)
    RCURLY          reduce using rule 60 (codeblock_aux -> function_definition .)


state 10

    (61) codeblock_aux -> condition_if .

    FUNCTION        reduce using rule 61 (codeblock_aux -> condition_if .)
    IF              reduce using rule 61 (codeblock_aux -> condition_if .)
    FOR             reduce using rule 61 (codeblock_aux -> condition_if .)
    WHILE           reduce using rule 61 (codeblock_aux -> condition_if .)
    NAME            reduce using rule 61 (codeblock_aux -> condition_if .)
    INT_TYPE        reduce using rule 61 (codeblock_aux -> condition_if .)
    STRING_TYPE     reduce using rule 61 (codeblock_aux -> condition_if .)
    DOUBLE_TYPE     reduce using rule 61 (codeblock_aux -> condition_if .)
    FLOAT_TYPE      reduce using rule 61 (codeblock_aux -> condition_if .)
    BOOL_TYPE       reduce using rule 61 (codeblock_aux -> condition_if .)
    $end            reduce using rule 61 (codeblock_aux -> condition_if .)
    RCURLY          reduce using rule 61 (codeblock_aux -> condition_if .)


state 11

    (62) codeblock_aux -> loop .

    FUNCTION        reduce using rule 62 (codeblock_aux -> loop .)
    IF              reduce using rule 62 (codeblock_aux -> loop .)
    FOR             reduce using rule 62 (codeblock_aux -> loop .)
    WHILE           reduce using rule 62 (codeblock_aux -> loop .)
    NAME            reduce using rule 62 (codeblock_aux -> loop .)
    INT_TYPE        reduce using rule 62 (codeblock_aux -> loop .)
    STRING_TYPE     reduce using rule 62 (codeblock_aux -> loop .)
    DOUBLE_TYPE     reduce using rule 62 (codeblock_aux -> loop .)
    FLOAT_TYPE      reduce using rule 62 (codeblock_aux -> loop .)
    BOOL_TYPE       reduce using rule 62 (codeblock_aux -> loop .)
    $end            reduce using rule 62 (codeblock_aux -> loop .)
    RCURLY          reduce using rule 62 (codeblock_aux -> loop .)


state 12

    (54) statement -> statement_aux . SEMICOLON

    SEMICOLON       shift and go to state 29


state 13

    (29) function_definition -> FUNCTION . NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope

    NAME            shift and go to state 30


state 14

    (52) assign -> NAME . n_name_assign EQUAL expression
    (30) function_call -> NAME . LPARENTHESIS parameter_list RPARENTHESIS
    (53) n_name_assign -> .

    LPARENTHESIS    shift and go to state 32
    EQUAL           reduce using rule 53 (n_name_assign -> .)

    n_name_assign                  shift and go to state 31

state 15

    (67) condition_if -> IF . LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else

    LPARENTHESIS    shift and go to state 33


state 16

    (63) loop -> forloop .

    FUNCTION        reduce using rule 63 (loop -> forloop .)
    IF              reduce using rule 63 (loop -> forloop .)
    FOR             reduce using rule 63 (loop -> forloop .)
    WHILE           reduce using rule 63 (loop -> forloop .)
    NAME            reduce using rule 63 (loop -> forloop .)
    INT_TYPE        reduce using rule 63 (loop -> forloop .)
    STRING_TYPE     reduce using rule 63 (loop -> forloop .)
    DOUBLE_TYPE     reduce using rule 63 (loop -> forloop .)
    FLOAT_TYPE      reduce using rule 63 (loop -> forloop .)
    BOOL_TYPE       reduce using rule 63 (loop -> forloop .)
    $end            reduce using rule 63 (loop -> forloop .)
    RCURLY          reduce using rule 63 (loop -> forloop .)


state 17

    (64) loop -> whileloop .

    FUNCTION        reduce using rule 64 (loop -> whileloop .)
    IF              reduce using rule 64 (loop -> whileloop .)
    FOR             reduce using rule 64 (loop -> whileloop .)
    WHILE           reduce using rule 64 (loop -> whileloop .)
    NAME            reduce using rule 64 (loop -> whileloop .)
    INT_TYPE        reduce using rule 64 (loop -> whileloop .)
    STRING_TYPE     reduce using rule 64 (loop -> whileloop .)
    DOUBLE_TYPE     reduce using rule 64 (loop -> whileloop .)
    FLOAT_TYPE      reduce using rule 64 (loop -> whileloop .)
    BOOL_TYPE       reduce using rule 64 (loop -> whileloop .)
    $end            reduce using rule 64 (loop -> whileloop .)
    RCURLY          reduce using rule 64 (loop -> whileloop .)


state 18

    (55) statement_aux -> assign .

    SEMICOLON       reduce using rule 55 (statement_aux -> assign .)


state 19

    (56) statement_aux -> function_call .

    SEMICOLON       reduce using rule 56 (statement_aux -> function_call .)


state 20

    (66) forloop -> FOR . LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope

    LPARENTHESIS    shift and go to state 34


state 21

    (65) whileloop -> WHILE . LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope

    LPARENTHESIS    shift and go to state 35


state 22

    (51) assign -> type . NAME n_name_assign EQUAL expression

    NAME            shift and go to state 36


state 23

    (8) type -> INT_TYPE . n_seen_type
    (1) n_seen_type -> .

    NAME            reduce using rule 1 (n_seen_type -> .)
    LCURLY          reduce using rule 1 (n_seen_type -> .)

    n_seen_type                    shift and go to state 37

state 24

    (9) type -> STRING_TYPE . n_seen_type
    (1) n_seen_type -> .

    NAME            reduce using rule 1 (n_seen_type -> .)
    LCURLY          reduce using rule 1 (n_seen_type -> .)

    n_seen_type                    shift and go to state 38

state 25

    (10) type -> DOUBLE_TYPE . n_seen_type
    (1) n_seen_type -> .

    NAME            reduce using rule 1 (n_seen_type -> .)
    LCURLY          reduce using rule 1 (n_seen_type -> .)

    n_seen_type                    shift and go to state 39

state 26

    (11) type -> FLOAT_TYPE . n_seen_type
    (1) n_seen_type -> .

    NAME            reduce using rule 1 (n_seen_type -> .)
    LCURLY          reduce using rule 1 (n_seen_type -> .)

    n_seen_type                    shift and go to state 40

state 27

    (12) type -> BOOL_TYPE . n_seen_type
    (1) n_seen_type -> .

    NAME            reduce using rule 1 (n_seen_type -> .)
    LCURLY          reduce using rule 1 (n_seen_type -> .)

    n_seen_type                    shift and go to state 41

state 28

    (58) codeblock -> codeblock_aux codeblock .

    $end            reduce using rule 58 (codeblock -> codeblock_aux codeblock .)
    RCURLY          reduce using rule 58 (codeblock -> codeblock_aux codeblock .)


state 29

    (54) statement -> statement_aux SEMICOLON .

    FUNCTION        reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    IF              reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    FOR             reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    WHILE           reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    NAME            reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    INT_TYPE        reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    STRING_TYPE     reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    FLOAT_TYPE      reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    BOOL_TYPE       reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    $end            reduce using rule 54 (statement -> statement_aux SEMICOLON .)
    RCURLY          reduce using rule 54 (statement -> statement_aux SEMICOLON .)


state 30

    (29) function_definition -> FUNCTION NAME . n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (2) n_open_new_scope -> .

    INT_TYPE        reduce using rule 2 (n_open_new_scope -> .)
    STRING_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    DOUBLE_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    FLOAT_TYPE      reduce using rule 2 (n_open_new_scope -> .)
    BOOL_TYPE       reduce using rule 2 (n_open_new_scope -> .)
    NAME            reduce using rule 2 (n_open_new_scope -> .)
    DOUBLEDOT       reduce using rule 2 (n_open_new_scope -> .)

    n_open_new_scope               shift and go to state 42

state 31

    (52) assign -> NAME n_name_assign . EQUAL expression

    EQUAL           shift and go to state 43


state 32

    (30) function_call -> NAME LPARENTHESIS . parameter_list RPARENTHESIS
    (31) parameter_list -> . empty
    (32) parameter_list -> . parameter
    (33) parameter_list -> . parameter COMMA parameter_list
    (4) empty -> .
    (34) parameter -> . type NAME n_name_assign
    (35) parameter -> . assign
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression

    RPARENTHESIS    reduce using rule 4 (empty -> .)
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27
    NAME            shift and go to state 44

    parameter_list                 shift and go to state 45
    empty                          shift and go to state 46
    parameter                      shift and go to state 47
    type                           shift and go to state 48
    assign                         shift and go to state 49

state 33

    (67) condition_if -> IF LPARENTHESIS . expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (36) expression -> . exp
    (37) expression -> . exp logic_operator exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    expression                     shift and go to state 51
    exp                            shift and go to state 52
    termino                        shift and go to state 53
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 34

    (66) forloop -> FOR LPARENTHESIS . n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (2) n_open_new_scope -> .

    NAME            reduce using rule 2 (n_open_new_scope -> .)
    INT_TYPE        reduce using rule 2 (n_open_new_scope -> .)
    STRING_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    DOUBLE_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    FLOAT_TYPE      reduce using rule 2 (n_open_new_scope -> .)
    BOOL_TYPE       reduce using rule 2 (n_open_new_scope -> .)

    n_open_new_scope               shift and go to state 64

state 35

    (65) whileloop -> WHILE LPARENTHESIS . expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (36) expression -> . exp
    (37) expression -> . exp logic_operator exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    expression                     shift and go to state 65
    exp                            shift and go to state 52
    termino                        shift and go to state 53
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 36

    (51) assign -> type NAME . n_name_assign EQUAL expression
    (53) n_name_assign -> .

    EQUAL           reduce using rule 53 (n_name_assign -> .)

    n_name_assign                  shift and go to state 66

state 37

    (8) type -> INT_TYPE n_seen_type .

    NAME            reduce using rule 8 (type -> INT_TYPE n_seen_type .)
    LCURLY          reduce using rule 8 (type -> INT_TYPE n_seen_type .)


state 38

    (9) type -> STRING_TYPE n_seen_type .

    NAME            reduce using rule 9 (type -> STRING_TYPE n_seen_type .)
    LCURLY          reduce using rule 9 (type -> STRING_TYPE n_seen_type .)


state 39

    (10) type -> DOUBLE_TYPE n_seen_type .

    NAME            reduce using rule 10 (type -> DOUBLE_TYPE n_seen_type .)
    LCURLY          reduce using rule 10 (type -> DOUBLE_TYPE n_seen_type .)


state 40

    (11) type -> FLOAT_TYPE n_seen_type .

    NAME            reduce using rule 11 (type -> FLOAT_TYPE n_seen_type .)
    LCURLY          reduce using rule 11 (type -> FLOAT_TYPE n_seen_type .)


state 41

    (12) type -> BOOL_TYPE n_seen_type .

    NAME            reduce using rule 12 (type -> BOOL_TYPE n_seen_type .)
    LCURLY          reduce using rule 12 (type -> BOOL_TYPE n_seen_type .)


state 42

    (29) function_definition -> FUNCTION NAME n_open_new_scope . parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (31) parameter_list -> . empty
    (32) parameter_list -> . parameter
    (33) parameter_list -> . parameter COMMA parameter_list
    (4) empty -> .
    (34) parameter -> . type NAME n_name_assign
    (35) parameter -> . assign
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression

    DOUBLEDOT       reduce using rule 4 (empty -> .)
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27
    NAME            shift and go to state 44

    parameter_list                 shift and go to state 67
    empty                          shift and go to state 46
    parameter                      shift and go to state 47
    type                           shift and go to state 48
    assign                         shift and go to state 49

state 43

    (52) assign -> NAME n_name_assign EQUAL . expression
    (36) expression -> . exp
    (37) expression -> . exp logic_operator exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    expression                     shift and go to state 68
    exp                            shift and go to state 52
    termino                        shift and go to state 53
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 44

    (52) assign -> NAME . n_name_assign EQUAL expression
    (53) n_name_assign -> .

    EQUAL           reduce using rule 53 (n_name_assign -> .)

    n_name_assign                  shift and go to state 31

state 45

    (30) function_call -> NAME LPARENTHESIS parameter_list . RPARENTHESIS

    RPARENTHESIS    shift and go to state 69


state 46

    (31) parameter_list -> empty .

    RPARENTHESIS    reduce using rule 31 (parameter_list -> empty .)
    DOUBLEDOT       reduce using rule 31 (parameter_list -> empty .)


state 47

    (32) parameter_list -> parameter .
    (33) parameter_list -> parameter . COMMA parameter_list

    RPARENTHESIS    reduce using rule 32 (parameter_list -> parameter .)
    DOUBLEDOT       reduce using rule 32 (parameter_list -> parameter .)
    COMMA           shift and go to state 70


state 48

    (34) parameter -> type . NAME n_name_assign
    (51) assign -> type . NAME n_name_assign EQUAL expression

    NAME            shift and go to state 71


state 49

    (35) parameter -> assign .

    COMMA           reduce using rule 35 (parameter -> assign .)
    RPARENTHESIS    reduce using rule 35 (parameter -> assign .)
    DOUBLEDOT       reduce using rule 35 (parameter -> assign .)


state 50

    (44) factor -> LPARENTHESIS . expression RPARENTHESIS
    (36) expression -> . exp
    (37) expression -> . exp logic_operator exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    expression                     shift and go to state 72
    exp                            shift and go to state 52
    termino                        shift and go to state 53
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 51

    (67) condition_if -> IF LPARENTHESIS expression . RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else

    RPARENTHESIS    shift and go to state 73


state 52

    (36) expression -> exp .
    (37) expression -> exp . logic_operator exp
    (13) logic_operator -> . GREATERTHAN
    (14) logic_operator -> . LESSTHAN
    (15) logic_operator -> . EQUALEQUAL
    (16) logic_operator -> . LESSTHANOREQUAL
    (17) logic_operator -> . GREATERTHANOREQUAL
    (18) logic_operator -> . NOTEQUAL

    RPARENTHESIS    reduce using rule 36 (expression -> exp .)
    SEMICOLON       reduce using rule 36 (expression -> exp .)
    COMMA           reduce using rule 36 (expression -> exp .)
    DOUBLEDOT       reduce using rule 36 (expression -> exp .)
    GREATERTHAN     shift and go to state 75
    LESSTHAN        shift and go to state 76
    EQUALEQUAL      shift and go to state 77
    LESSTHANOREQUAL shift and go to state 78
    GREATERTHANOREQUAL shift and go to state 79
    NOTEQUAL        shift and go to state 80

    logic_operator                 shift and go to state 74

state 53

    (38) exp -> termino .
    (39) exp -> termino . PLUS exp
    (40) exp -> termino . MINUS exp

    GREATERTHAN     reduce using rule 38 (exp -> termino .)
    LESSTHAN        reduce using rule 38 (exp -> termino .)
    EQUALEQUAL      reduce using rule 38 (exp -> termino .)
    LESSTHANOREQUAL reduce using rule 38 (exp -> termino .)
    GREATERTHANOREQUAL reduce using rule 38 (exp -> termino .)
    NOTEQUAL        reduce using rule 38 (exp -> termino .)
    RPARENTHESIS    reduce using rule 38 (exp -> termino .)
    SEMICOLON       reduce using rule 38 (exp -> termino .)
    COMMA           reduce using rule 38 (exp -> termino .)
    DOUBLEDOT       reduce using rule 38 (exp -> termino .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82


state 54

    (45) factor -> PLUS . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    value                          shift and go to state 83
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 55

    (46) factor -> MINUS . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    value                          shift and go to state 84
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 56

    (41) termino -> factor .
    (42) termino -> factor . TIMES termino
    (43) termino -> factor . DIVIDE termino

    PLUS            reduce using rule 41 (termino -> factor .)
    MINUS           reduce using rule 41 (termino -> factor .)
    GREATERTHAN     reduce using rule 41 (termino -> factor .)
    LESSTHAN        reduce using rule 41 (termino -> factor .)
    EQUALEQUAL      reduce using rule 41 (termino -> factor .)
    LESSTHANOREQUAL reduce using rule 41 (termino -> factor .)
    GREATERTHANOREQUAL reduce using rule 41 (termino -> factor .)
    NOTEQUAL        reduce using rule 41 (termino -> factor .)
    RPARENTHESIS    reduce using rule 41 (termino -> factor .)
    SEMICOLON       reduce using rule 41 (termino -> factor .)
    COMMA           reduce using rule 41 (termino -> factor .)
    DOUBLEDOT       reduce using rule 41 (termino -> factor .)
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86


state 57

    (47) factor -> value .

    TIMES           reduce using rule 47 (factor -> value .)
    DIVIDE          reduce using rule 47 (factor -> value .)
    PLUS            reduce using rule 47 (factor -> value .)
    MINUS           reduce using rule 47 (factor -> value .)
    GREATERTHAN     reduce using rule 47 (factor -> value .)
    LESSTHAN        reduce using rule 47 (factor -> value .)
    EQUALEQUAL      reduce using rule 47 (factor -> value .)
    LESSTHANOREQUAL reduce using rule 47 (factor -> value .)
    GREATERTHANOREQUAL reduce using rule 47 (factor -> value .)
    NOTEQUAL        reduce using rule 47 (factor -> value .)
    RPARENTHESIS    reduce using rule 47 (factor -> value .)
    SEMICOLON       reduce using rule 47 (factor -> value .)
    COMMA           reduce using rule 47 (factor -> value .)
    DOUBLEDOT       reduce using rule 47 (factor -> value .)


state 58

    (48) value -> function_call .

    TIMES           reduce using rule 48 (value -> function_call .)
    DIVIDE          reduce using rule 48 (value -> function_call .)
    PLUS            reduce using rule 48 (value -> function_call .)
    MINUS           reduce using rule 48 (value -> function_call .)
    GREATERTHAN     reduce using rule 48 (value -> function_call .)
    LESSTHAN        reduce using rule 48 (value -> function_call .)
    EQUALEQUAL      reduce using rule 48 (value -> function_call .)
    LESSTHANOREQUAL reduce using rule 48 (value -> function_call .)
    GREATERTHANOREQUAL reduce using rule 48 (value -> function_call .)
    NOTEQUAL        reduce using rule 48 (value -> function_call .)
    RPARENTHESIS    reduce using rule 48 (value -> function_call .)
    SEMICOLON       reduce using rule 48 (value -> function_call .)
    COMMA           reduce using rule 48 (value -> function_call .)
    DOUBLEDOT       reduce using rule 48 (value -> function_call .)


state 59

    (49) value -> literal .

    TIMES           reduce using rule 49 (value -> literal .)
    DIVIDE          reduce using rule 49 (value -> literal .)
    PLUS            reduce using rule 49 (value -> literal .)
    MINUS           reduce using rule 49 (value -> literal .)
    GREATERTHAN     reduce using rule 49 (value -> literal .)
    LESSTHAN        reduce using rule 49 (value -> literal .)
    EQUALEQUAL      reduce using rule 49 (value -> literal .)
    LESSTHANOREQUAL reduce using rule 49 (value -> literal .)
    GREATERTHANOREQUAL reduce using rule 49 (value -> literal .)
    NOTEQUAL        reduce using rule 49 (value -> literal .)
    RPARENTHESIS    reduce using rule 49 (value -> literal .)
    SEMICOLON       reduce using rule 49 (value -> literal .)
    COMMA           reduce using rule 49 (value -> literal .)
    DOUBLEDOT       reduce using rule 49 (value -> literal .)


state 60

    (50) value -> NAME .
    (30) function_call -> NAME . LPARENTHESIS parameter_list RPARENTHESIS

    TIMES           reduce using rule 50 (value -> NAME .)
    DIVIDE          reduce using rule 50 (value -> NAME .)
    PLUS            reduce using rule 50 (value -> NAME .)
    MINUS           reduce using rule 50 (value -> NAME .)
    GREATERTHAN     reduce using rule 50 (value -> NAME .)
    LESSTHAN        reduce using rule 50 (value -> NAME .)
    EQUALEQUAL      reduce using rule 50 (value -> NAME .)
    LESSTHANOREQUAL reduce using rule 50 (value -> NAME .)
    GREATERTHANOREQUAL reduce using rule 50 (value -> NAME .)
    NOTEQUAL        reduce using rule 50 (value -> NAME .)
    RPARENTHESIS    reduce using rule 50 (value -> NAME .)
    SEMICOLON       reduce using rule 50 (value -> NAME .)
    COMMA           reduce using rule 50 (value -> NAME .)
    DOUBLEDOT       reduce using rule 50 (value -> NAME .)
    LPARENTHESIS    shift and go to state 32


state 61

    (24) literal -> FLOAT .

    TIMES           reduce using rule 24 (literal -> FLOAT .)
    DIVIDE          reduce using rule 24 (literal -> FLOAT .)
    PLUS            reduce using rule 24 (literal -> FLOAT .)
    MINUS           reduce using rule 24 (literal -> FLOAT .)
    GREATERTHAN     reduce using rule 24 (literal -> FLOAT .)
    LESSTHAN        reduce using rule 24 (literal -> FLOAT .)
    EQUALEQUAL      reduce using rule 24 (literal -> FLOAT .)
    LESSTHANOREQUAL reduce using rule 24 (literal -> FLOAT .)
    GREATERTHANOREQUAL reduce using rule 24 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 24 (literal -> FLOAT .)
    RPARENTHESIS    reduce using rule 24 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 24 (literal -> FLOAT .)
    COMMA           reduce using rule 24 (literal -> FLOAT .)
    DOUBLEDOT       reduce using rule 24 (literal -> FLOAT .)


state 62

    (25) literal -> INT .

    TIMES           reduce using rule 25 (literal -> INT .)
    DIVIDE          reduce using rule 25 (literal -> INT .)
    PLUS            reduce using rule 25 (literal -> INT .)
    MINUS           reduce using rule 25 (literal -> INT .)
    GREATERTHAN     reduce using rule 25 (literal -> INT .)
    LESSTHAN        reduce using rule 25 (literal -> INT .)
    EQUALEQUAL      reduce using rule 25 (literal -> INT .)
    LESSTHANOREQUAL reduce using rule 25 (literal -> INT .)
    GREATERTHANOREQUAL reduce using rule 25 (literal -> INT .)
    NOTEQUAL        reduce using rule 25 (literal -> INT .)
    RPARENTHESIS    reduce using rule 25 (literal -> INT .)
    SEMICOLON       reduce using rule 25 (literal -> INT .)
    COMMA           reduce using rule 25 (literal -> INT .)
    DOUBLEDOT       reduce using rule 25 (literal -> INT .)


state 63

    (26) literal -> STRING .

    TIMES           reduce using rule 26 (literal -> STRING .)
    DIVIDE          reduce using rule 26 (literal -> STRING .)
    PLUS            reduce using rule 26 (literal -> STRING .)
    MINUS           reduce using rule 26 (literal -> STRING .)
    GREATERTHAN     reduce using rule 26 (literal -> STRING .)
    LESSTHAN        reduce using rule 26 (literal -> STRING .)
    EQUALEQUAL      reduce using rule 26 (literal -> STRING .)
    LESSTHANOREQUAL reduce using rule 26 (literal -> STRING .)
    GREATERTHANOREQUAL reduce using rule 26 (literal -> STRING .)
    NOTEQUAL        reduce using rule 26 (literal -> STRING .)
    RPARENTHESIS    reduce using rule 26 (literal -> STRING .)
    SEMICOLON       reduce using rule 26 (literal -> STRING .)
    COMMA           reduce using rule 26 (literal -> STRING .)
    DOUBLEDOT       reduce using rule 26 (literal -> STRING .)


state 64

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope . assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    NAME            shift and go to state 44
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    assign                         shift and go to state 87
    type                           shift and go to state 22

state 65

    (65) whileloop -> WHILE LPARENTHESIS expression . RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope

    RPARENTHESIS    shift and go to state 88


state 66

    (51) assign -> type NAME n_name_assign . EQUAL expression

    EQUAL           shift and go to state 89


state 67

    (29) function_definition -> FUNCTION NAME n_open_new_scope parameter_list . DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope

    DOUBLEDOT       shift and go to state 90


state 68

    (52) assign -> NAME n_name_assign EQUAL expression .

    SEMICOLON       reduce using rule 52 (assign -> NAME n_name_assign EQUAL expression .)
    COMMA           reduce using rule 52 (assign -> NAME n_name_assign EQUAL expression .)
    RPARENTHESIS    reduce using rule 52 (assign -> NAME n_name_assign EQUAL expression .)
    DOUBLEDOT       reduce using rule 52 (assign -> NAME n_name_assign EQUAL expression .)


state 69

    (30) function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .

    SEMICOLON       reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    TIMES           reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    DIVIDE          reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    PLUS            reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    MINUS           reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    GREATERTHAN     reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    LESSTHAN        reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    EQUALEQUAL      reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    LESSTHANOREQUAL reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    GREATERTHANOREQUAL reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    NOTEQUAL        reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    RPARENTHESIS    reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    COMMA           reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)
    DOUBLEDOT       reduce using rule 30 (function_call -> NAME LPARENTHESIS parameter_list RPARENTHESIS .)


state 70

    (33) parameter_list -> parameter COMMA . parameter_list
    (31) parameter_list -> . empty
    (32) parameter_list -> . parameter
    (33) parameter_list -> . parameter COMMA parameter_list
    (4) empty -> .
    (34) parameter -> . type NAME n_name_assign
    (35) parameter -> . assign
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression

    RPARENTHESIS    reduce using rule 4 (empty -> .)
    DOUBLEDOT       reduce using rule 4 (empty -> .)
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27
    NAME            shift and go to state 44

    parameter                      shift and go to state 47
    parameter_list                 shift and go to state 91
    empty                          shift and go to state 46
    type                           shift and go to state 48
    assign                         shift and go to state 49

state 71

    (34) parameter -> type NAME . n_name_assign
    (51) assign -> type NAME . n_name_assign EQUAL expression
    (53) n_name_assign -> .

    EQUAL           reduce using rule 53 (n_name_assign -> .)
    COMMA           reduce using rule 53 (n_name_assign -> .)
    RPARENTHESIS    reduce using rule 53 (n_name_assign -> .)
    DOUBLEDOT       reduce using rule 53 (n_name_assign -> .)

    n_name_assign                  shift and go to state 92

state 72

    (44) factor -> LPARENTHESIS expression . RPARENTHESIS

    RPARENTHESIS    shift and go to state 93


state 73

    (67) condition_if -> IF LPARENTHESIS expression RPARENTHESIS . LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else

    LCURLY          shift and go to state 94


state 74

    (37) expression -> exp logic_operator . exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    exp                            shift and go to state 95
    termino                        shift and go to state 53
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 75

    (13) logic_operator -> GREATERTHAN .

    LPARENTHESIS    reduce using rule 13 (logic_operator -> GREATERTHAN .)
    PLUS            reduce using rule 13 (logic_operator -> GREATERTHAN .)
    MINUS           reduce using rule 13 (logic_operator -> GREATERTHAN .)
    NAME            reduce using rule 13 (logic_operator -> GREATERTHAN .)
    FLOAT           reduce using rule 13 (logic_operator -> GREATERTHAN .)
    INT             reduce using rule 13 (logic_operator -> GREATERTHAN .)
    STRING          reduce using rule 13 (logic_operator -> GREATERTHAN .)


state 76

    (14) logic_operator -> LESSTHAN .

    LPARENTHESIS    reduce using rule 14 (logic_operator -> LESSTHAN .)
    PLUS            reduce using rule 14 (logic_operator -> LESSTHAN .)
    MINUS           reduce using rule 14 (logic_operator -> LESSTHAN .)
    NAME            reduce using rule 14 (logic_operator -> LESSTHAN .)
    FLOAT           reduce using rule 14 (logic_operator -> LESSTHAN .)
    INT             reduce using rule 14 (logic_operator -> LESSTHAN .)
    STRING          reduce using rule 14 (logic_operator -> LESSTHAN .)


state 77

    (15) logic_operator -> EQUALEQUAL .

    LPARENTHESIS    reduce using rule 15 (logic_operator -> EQUALEQUAL .)
    PLUS            reduce using rule 15 (logic_operator -> EQUALEQUAL .)
    MINUS           reduce using rule 15 (logic_operator -> EQUALEQUAL .)
    NAME            reduce using rule 15 (logic_operator -> EQUALEQUAL .)
    FLOAT           reduce using rule 15 (logic_operator -> EQUALEQUAL .)
    INT             reduce using rule 15 (logic_operator -> EQUALEQUAL .)
    STRING          reduce using rule 15 (logic_operator -> EQUALEQUAL .)


state 78

    (16) logic_operator -> LESSTHANOREQUAL .

    LPARENTHESIS    reduce using rule 16 (logic_operator -> LESSTHANOREQUAL .)
    PLUS            reduce using rule 16 (logic_operator -> LESSTHANOREQUAL .)
    MINUS           reduce using rule 16 (logic_operator -> LESSTHANOREQUAL .)
    NAME            reduce using rule 16 (logic_operator -> LESSTHANOREQUAL .)
    FLOAT           reduce using rule 16 (logic_operator -> LESSTHANOREQUAL .)
    INT             reduce using rule 16 (logic_operator -> LESSTHANOREQUAL .)
    STRING          reduce using rule 16 (logic_operator -> LESSTHANOREQUAL .)


state 79

    (17) logic_operator -> GREATERTHANOREQUAL .

    LPARENTHESIS    reduce using rule 17 (logic_operator -> GREATERTHANOREQUAL .)
    PLUS            reduce using rule 17 (logic_operator -> GREATERTHANOREQUAL .)
    MINUS           reduce using rule 17 (logic_operator -> GREATERTHANOREQUAL .)
    NAME            reduce using rule 17 (logic_operator -> GREATERTHANOREQUAL .)
    FLOAT           reduce using rule 17 (logic_operator -> GREATERTHANOREQUAL .)
    INT             reduce using rule 17 (logic_operator -> GREATERTHANOREQUAL .)
    STRING          reduce using rule 17 (logic_operator -> GREATERTHANOREQUAL .)


state 80

    (18) logic_operator -> NOTEQUAL .

    LPARENTHESIS    reduce using rule 18 (logic_operator -> NOTEQUAL .)
    PLUS            reduce using rule 18 (logic_operator -> NOTEQUAL .)
    MINUS           reduce using rule 18 (logic_operator -> NOTEQUAL .)
    NAME            reduce using rule 18 (logic_operator -> NOTEQUAL .)
    FLOAT           reduce using rule 18 (logic_operator -> NOTEQUAL .)
    INT             reduce using rule 18 (logic_operator -> NOTEQUAL .)
    STRING          reduce using rule 18 (logic_operator -> NOTEQUAL .)


state 81

    (39) exp -> termino PLUS . exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    termino                        shift and go to state 53
    exp                            shift and go to state 96
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 82

    (40) exp -> termino MINUS . exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    termino                        shift and go to state 53
    exp                            shift and go to state 97
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 83

    (45) factor -> PLUS value .

    TIMES           reduce using rule 45 (factor -> PLUS value .)
    DIVIDE          reduce using rule 45 (factor -> PLUS value .)
    PLUS            reduce using rule 45 (factor -> PLUS value .)
    MINUS           reduce using rule 45 (factor -> PLUS value .)
    GREATERTHAN     reduce using rule 45 (factor -> PLUS value .)
    LESSTHAN        reduce using rule 45 (factor -> PLUS value .)
    EQUALEQUAL      reduce using rule 45 (factor -> PLUS value .)
    LESSTHANOREQUAL reduce using rule 45 (factor -> PLUS value .)
    GREATERTHANOREQUAL reduce using rule 45 (factor -> PLUS value .)
    NOTEQUAL        reduce using rule 45 (factor -> PLUS value .)
    RPARENTHESIS    reduce using rule 45 (factor -> PLUS value .)
    SEMICOLON       reduce using rule 45 (factor -> PLUS value .)
    COMMA           reduce using rule 45 (factor -> PLUS value .)
    DOUBLEDOT       reduce using rule 45 (factor -> PLUS value .)


state 84

    (46) factor -> MINUS value .

    TIMES           reduce using rule 46 (factor -> MINUS value .)
    DIVIDE          reduce using rule 46 (factor -> MINUS value .)
    PLUS            reduce using rule 46 (factor -> MINUS value .)
    MINUS           reduce using rule 46 (factor -> MINUS value .)
    GREATERTHAN     reduce using rule 46 (factor -> MINUS value .)
    LESSTHAN        reduce using rule 46 (factor -> MINUS value .)
    EQUALEQUAL      reduce using rule 46 (factor -> MINUS value .)
    LESSTHANOREQUAL reduce using rule 46 (factor -> MINUS value .)
    GREATERTHANOREQUAL reduce using rule 46 (factor -> MINUS value .)
    NOTEQUAL        reduce using rule 46 (factor -> MINUS value .)
    RPARENTHESIS    reduce using rule 46 (factor -> MINUS value .)
    SEMICOLON       reduce using rule 46 (factor -> MINUS value .)
    COMMA           reduce using rule 46 (factor -> MINUS value .)
    DOUBLEDOT       reduce using rule 46 (factor -> MINUS value .)


state 85

    (42) termino -> factor TIMES . termino
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    factor                         shift and go to state 56
    termino                        shift and go to state 98
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 86

    (43) termino -> factor DIVIDE . termino
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    factor                         shift and go to state 56
    termino                        shift and go to state 99
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 87

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign . DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope

    DOUBLEDOT       shift and go to state 100


state 88

    (65) whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS . LCURLY n_open_new_scope codeblock RCURLY n_close_scope

    LCURLY          shift and go to state 101


state 89

    (51) assign -> type NAME n_name_assign EQUAL . expression
    (36) expression -> . exp
    (37) expression -> . exp logic_operator exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    expression                     shift and go to state 102
    exp                            shift and go to state 52
    termino                        shift and go to state 53
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 90

    (29) function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT . function_type LCURLY codeblock RCURLY n_close_scope
    (27) function_type -> . type
    (28) function_type -> . VOID
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    VOID            shift and go to state 105
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    function_type                  shift and go to state 103
    type                           shift and go to state 104

state 91

    (33) parameter_list -> parameter COMMA parameter_list .

    RPARENTHESIS    reduce using rule 33 (parameter_list -> parameter COMMA parameter_list .)
    DOUBLEDOT       reduce using rule 33 (parameter_list -> parameter COMMA parameter_list .)


state 92

    (34) parameter -> type NAME n_name_assign .
    (51) assign -> type NAME n_name_assign . EQUAL expression

    COMMA           reduce using rule 34 (parameter -> type NAME n_name_assign .)
    RPARENTHESIS    reduce using rule 34 (parameter -> type NAME n_name_assign .)
    DOUBLEDOT       reduce using rule 34 (parameter -> type NAME n_name_assign .)
    EQUAL           shift and go to state 89


state 93

    (44) factor -> LPARENTHESIS expression RPARENTHESIS .

    TIMES           reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    DIVIDE          reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    PLUS            reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    MINUS           reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    GREATERTHAN     reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    LESSTHAN        reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    EQUALEQUAL      reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    LESSTHANOREQUAL reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    GREATERTHANOREQUAL reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    NOTEQUAL        reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    RPARENTHESIS    reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    SEMICOLON       reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    COMMA           reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)
    DOUBLEDOT       reduce using rule 44 (factor -> LPARENTHESIS expression RPARENTHESIS .)


state 94

    (67) condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY . n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (2) n_open_new_scope -> .

    FUNCTION        reduce using rule 2 (n_open_new_scope -> .)
    IF              reduce using rule 2 (n_open_new_scope -> .)
    FOR             reduce using rule 2 (n_open_new_scope -> .)
    WHILE           reduce using rule 2 (n_open_new_scope -> .)
    NAME            reduce using rule 2 (n_open_new_scope -> .)
    INT_TYPE        reduce using rule 2 (n_open_new_scope -> .)
    STRING_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    DOUBLE_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    FLOAT_TYPE      reduce using rule 2 (n_open_new_scope -> .)
    BOOL_TYPE       reduce using rule 2 (n_open_new_scope -> .)
    RCURLY          reduce using rule 2 (n_open_new_scope -> .)

    n_open_new_scope               shift and go to state 106

state 95

    (37) expression -> exp logic_operator exp .

    RPARENTHESIS    reduce using rule 37 (expression -> exp logic_operator exp .)
    SEMICOLON       reduce using rule 37 (expression -> exp logic_operator exp .)
    COMMA           reduce using rule 37 (expression -> exp logic_operator exp .)
    DOUBLEDOT       reduce using rule 37 (expression -> exp logic_operator exp .)


state 96

    (39) exp -> termino PLUS exp .

    GREATERTHAN     reduce using rule 39 (exp -> termino PLUS exp .)
    LESSTHAN        reduce using rule 39 (exp -> termino PLUS exp .)
    EQUALEQUAL      reduce using rule 39 (exp -> termino PLUS exp .)
    LESSTHANOREQUAL reduce using rule 39 (exp -> termino PLUS exp .)
    GREATERTHANOREQUAL reduce using rule 39 (exp -> termino PLUS exp .)
    NOTEQUAL        reduce using rule 39 (exp -> termino PLUS exp .)
    RPARENTHESIS    reduce using rule 39 (exp -> termino PLUS exp .)
    SEMICOLON       reduce using rule 39 (exp -> termino PLUS exp .)
    COMMA           reduce using rule 39 (exp -> termino PLUS exp .)
    DOUBLEDOT       reduce using rule 39 (exp -> termino PLUS exp .)


state 97

    (40) exp -> termino MINUS exp .

    GREATERTHAN     reduce using rule 40 (exp -> termino MINUS exp .)
    LESSTHAN        reduce using rule 40 (exp -> termino MINUS exp .)
    EQUALEQUAL      reduce using rule 40 (exp -> termino MINUS exp .)
    LESSTHANOREQUAL reduce using rule 40 (exp -> termino MINUS exp .)
    GREATERTHANOREQUAL reduce using rule 40 (exp -> termino MINUS exp .)
    NOTEQUAL        reduce using rule 40 (exp -> termino MINUS exp .)
    RPARENTHESIS    reduce using rule 40 (exp -> termino MINUS exp .)
    SEMICOLON       reduce using rule 40 (exp -> termino MINUS exp .)
    COMMA           reduce using rule 40 (exp -> termino MINUS exp .)
    DOUBLEDOT       reduce using rule 40 (exp -> termino MINUS exp .)


state 98

    (42) termino -> factor TIMES termino .

    PLUS            reduce using rule 42 (termino -> factor TIMES termino .)
    MINUS           reduce using rule 42 (termino -> factor TIMES termino .)
    GREATERTHAN     reduce using rule 42 (termino -> factor TIMES termino .)
    LESSTHAN        reduce using rule 42 (termino -> factor TIMES termino .)
    EQUALEQUAL      reduce using rule 42 (termino -> factor TIMES termino .)
    LESSTHANOREQUAL reduce using rule 42 (termino -> factor TIMES termino .)
    GREATERTHANOREQUAL reduce using rule 42 (termino -> factor TIMES termino .)
    NOTEQUAL        reduce using rule 42 (termino -> factor TIMES termino .)
    RPARENTHESIS    reduce using rule 42 (termino -> factor TIMES termino .)
    SEMICOLON       reduce using rule 42 (termino -> factor TIMES termino .)
    COMMA           reduce using rule 42 (termino -> factor TIMES termino .)
    DOUBLEDOT       reduce using rule 42 (termino -> factor TIMES termino .)


state 99

    (43) termino -> factor DIVIDE termino .

    PLUS            reduce using rule 43 (termino -> factor DIVIDE termino .)
    MINUS           reduce using rule 43 (termino -> factor DIVIDE termino .)
    GREATERTHAN     reduce using rule 43 (termino -> factor DIVIDE termino .)
    LESSTHAN        reduce using rule 43 (termino -> factor DIVIDE termino .)
    EQUALEQUAL      reduce using rule 43 (termino -> factor DIVIDE termino .)
    LESSTHANOREQUAL reduce using rule 43 (termino -> factor DIVIDE termino .)
    GREATERTHANOREQUAL reduce using rule 43 (termino -> factor DIVIDE termino .)
    NOTEQUAL        reduce using rule 43 (termino -> factor DIVIDE termino .)
    RPARENTHESIS    reduce using rule 43 (termino -> factor DIVIDE termino .)
    SEMICOLON       reduce using rule 43 (termino -> factor DIVIDE termino .)
    COMMA           reduce using rule 43 (termino -> factor DIVIDE termino .)
    DOUBLEDOT       reduce using rule 43 (termino -> factor DIVIDE termino .)


state 100

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT . expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (36) expression -> . exp
    (37) expression -> . exp logic_operator exp
    (38) exp -> . termino
    (39) exp -> . termino PLUS exp
    (40) exp -> . termino MINUS exp
    (41) termino -> . factor
    (42) termino -> . factor TIMES termino
    (43) termino -> . factor DIVIDE termino
    (44) factor -> . LPARENTHESIS expression RPARENTHESIS
    (45) factor -> . PLUS value
    (46) factor -> . MINUS value
    (47) factor -> . value
    (48) value -> . function_call
    (49) value -> . literal
    (50) value -> . NAME
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (24) literal -> . FLOAT
    (25) literal -> . INT
    (26) literal -> . STRING

    LPARENTHESIS    shift and go to state 50
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    NAME            shift and go to state 60
    FLOAT           shift and go to state 61
    INT             shift and go to state 62
    STRING          shift and go to state 63

    expression                     shift and go to state 107
    exp                            shift and go to state 52
    termino                        shift and go to state 53
    factor                         shift and go to state 56
    value                          shift and go to state 57
    function_call                  shift and go to state 58
    literal                        shift and go to state 59

state 101

    (65) whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY . n_open_new_scope codeblock RCURLY n_close_scope
    (2) n_open_new_scope -> .

    FUNCTION        reduce using rule 2 (n_open_new_scope -> .)
    IF              reduce using rule 2 (n_open_new_scope -> .)
    FOR             reduce using rule 2 (n_open_new_scope -> .)
    WHILE           reduce using rule 2 (n_open_new_scope -> .)
    NAME            reduce using rule 2 (n_open_new_scope -> .)
    INT_TYPE        reduce using rule 2 (n_open_new_scope -> .)
    STRING_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    DOUBLE_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    FLOAT_TYPE      reduce using rule 2 (n_open_new_scope -> .)
    BOOL_TYPE       reduce using rule 2 (n_open_new_scope -> .)
    RCURLY          reduce using rule 2 (n_open_new_scope -> .)

    n_open_new_scope               shift and go to state 108

state 102

    (51) assign -> type NAME n_name_assign EQUAL expression .

    SEMICOLON       reduce using rule 51 (assign -> type NAME n_name_assign EQUAL expression .)
    COMMA           reduce using rule 51 (assign -> type NAME n_name_assign EQUAL expression .)
    RPARENTHESIS    reduce using rule 51 (assign -> type NAME n_name_assign EQUAL expression .)
    DOUBLEDOT       reduce using rule 51 (assign -> type NAME n_name_assign EQUAL expression .)


state 103

    (29) function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type . LCURLY codeblock RCURLY n_close_scope

    LCURLY          shift and go to state 109


state 104

    (27) function_type -> type .

    LCURLY          reduce using rule 27 (function_type -> type .)


state 105

    (28) function_type -> VOID .

    LCURLY          reduce using rule 28 (function_type -> VOID .)


state 106

    (67) condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope . codeblock RCURLY n_close_scope condition_else
    (57) codeblock -> . empty
    (58) codeblock -> . codeblock_aux codeblock
    (4) empty -> .
    (59) codeblock_aux -> . statement
    (60) codeblock_aux -> . function_definition
    (61) codeblock_aux -> . condition_if
    (62) codeblock_aux -> . loop
    (54) statement -> . statement_aux SEMICOLON
    (29) function_definition -> . FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (67) condition_if -> . IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (63) loop -> . forloop
    (64) loop -> . whileloop
    (55) statement_aux -> . assign
    (56) statement_aux -> . function_call
    (66) forloop -> . FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (65) whileloop -> . WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    RCURLY          reduce using rule 4 (empty -> .)
    FUNCTION        shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    NAME            shift and go to state 14
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    codeblock                      shift and go to state 110
    empty                          shift and go to state 6
    codeblock_aux                  shift and go to state 7
    statement                      shift and go to state 8
    function_definition            shift and go to state 9
    condition_if                   shift and go to state 10
    loop                           shift and go to state 11
    statement_aux                  shift and go to state 12
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assign                         shift and go to state 18
    function_call                  shift and go to state 19
    type                           shift and go to state 22

state 107

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression . DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope

    DOUBLEDOT       shift and go to state 111


state 108

    (65) whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope . codeblock RCURLY n_close_scope
    (57) codeblock -> . empty
    (58) codeblock -> . codeblock_aux codeblock
    (4) empty -> .
    (59) codeblock_aux -> . statement
    (60) codeblock_aux -> . function_definition
    (61) codeblock_aux -> . condition_if
    (62) codeblock_aux -> . loop
    (54) statement -> . statement_aux SEMICOLON
    (29) function_definition -> . FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (67) condition_if -> . IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (63) loop -> . forloop
    (64) loop -> . whileloop
    (55) statement_aux -> . assign
    (56) statement_aux -> . function_call
    (66) forloop -> . FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (65) whileloop -> . WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    RCURLY          reduce using rule 4 (empty -> .)
    FUNCTION        shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    NAME            shift and go to state 14
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    codeblock                      shift and go to state 112
    empty                          shift and go to state 6
    codeblock_aux                  shift and go to state 7
    statement                      shift and go to state 8
    function_definition            shift and go to state 9
    condition_if                   shift and go to state 10
    loop                           shift and go to state 11
    statement_aux                  shift and go to state 12
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assign                         shift and go to state 18
    function_call                  shift and go to state 19
    type                           shift and go to state 22

state 109

    (29) function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY . codeblock RCURLY n_close_scope
    (57) codeblock -> . empty
    (58) codeblock -> . codeblock_aux codeblock
    (4) empty -> .
    (59) codeblock_aux -> . statement
    (60) codeblock_aux -> . function_definition
    (61) codeblock_aux -> . condition_if
    (62) codeblock_aux -> . loop
    (54) statement -> . statement_aux SEMICOLON
    (29) function_definition -> . FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (67) condition_if -> . IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (63) loop -> . forloop
    (64) loop -> . whileloop
    (55) statement_aux -> . assign
    (56) statement_aux -> . function_call
    (66) forloop -> . FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (65) whileloop -> . WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    RCURLY          reduce using rule 4 (empty -> .)
    FUNCTION        shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    NAME            shift and go to state 14
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    codeblock                      shift and go to state 113
    empty                          shift and go to state 6
    codeblock_aux                  shift and go to state 7
    statement                      shift and go to state 8
    function_definition            shift and go to state 9
    condition_if                   shift and go to state 10
    loop                           shift and go to state 11
    statement_aux                  shift and go to state 12
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assign                         shift and go to state 18
    function_call                  shift and go to state 19
    type                           shift and go to state 22

state 110

    (67) condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock . RCURLY n_close_scope condition_else

    RCURLY          shift and go to state 114


state 111

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT . assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    NAME            shift and go to state 44
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    assign                         shift and go to state 115
    type                           shift and go to state 22

state 112

    (65) whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock . RCURLY n_close_scope

    RCURLY          shift and go to state 116


state 113

    (29) function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock . RCURLY n_close_scope

    RCURLY          shift and go to state 117


state 114

    (67) condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY . n_close_scope condition_else
    (3) n_close_scope -> .

    ELSE            reduce using rule 3 (n_close_scope -> .)
    FUNCTION        reduce using rule 3 (n_close_scope -> .)
    IF              reduce using rule 3 (n_close_scope -> .)
    FOR             reduce using rule 3 (n_close_scope -> .)
    WHILE           reduce using rule 3 (n_close_scope -> .)
    NAME            reduce using rule 3 (n_close_scope -> .)
    INT_TYPE        reduce using rule 3 (n_close_scope -> .)
    STRING_TYPE     reduce using rule 3 (n_close_scope -> .)
    DOUBLE_TYPE     reduce using rule 3 (n_close_scope -> .)
    FLOAT_TYPE      reduce using rule 3 (n_close_scope -> .)
    BOOL_TYPE       reduce using rule 3 (n_close_scope -> .)
    $end            reduce using rule 3 (n_close_scope -> .)
    RCURLY          reduce using rule 3 (n_close_scope -> .)

    n_close_scope                  shift and go to state 118

state 115

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign . RPARENTHESIS LCURLY codeblock RCURLY n_close_scope

    RPARENTHESIS    shift and go to state 119


state 116

    (65) whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY . n_close_scope
    (3) n_close_scope -> .

    FUNCTION        reduce using rule 3 (n_close_scope -> .)
    IF              reduce using rule 3 (n_close_scope -> .)
    FOR             reduce using rule 3 (n_close_scope -> .)
    WHILE           reduce using rule 3 (n_close_scope -> .)
    NAME            reduce using rule 3 (n_close_scope -> .)
    INT_TYPE        reduce using rule 3 (n_close_scope -> .)
    STRING_TYPE     reduce using rule 3 (n_close_scope -> .)
    DOUBLE_TYPE     reduce using rule 3 (n_close_scope -> .)
    FLOAT_TYPE      reduce using rule 3 (n_close_scope -> .)
    BOOL_TYPE       reduce using rule 3 (n_close_scope -> .)
    $end            reduce using rule 3 (n_close_scope -> .)
    RCURLY          reduce using rule 3 (n_close_scope -> .)

    n_close_scope                  shift and go to state 120

state 117

    (29) function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY . n_close_scope
    (3) n_close_scope -> .

    FUNCTION        reduce using rule 3 (n_close_scope -> .)
    IF              reduce using rule 3 (n_close_scope -> .)
    FOR             reduce using rule 3 (n_close_scope -> .)
    WHILE           reduce using rule 3 (n_close_scope -> .)
    NAME            reduce using rule 3 (n_close_scope -> .)
    INT_TYPE        reduce using rule 3 (n_close_scope -> .)
    STRING_TYPE     reduce using rule 3 (n_close_scope -> .)
    DOUBLE_TYPE     reduce using rule 3 (n_close_scope -> .)
    FLOAT_TYPE      reduce using rule 3 (n_close_scope -> .)
    BOOL_TYPE       reduce using rule 3 (n_close_scope -> .)
    $end            reduce using rule 3 (n_close_scope -> .)
    RCURLY          reduce using rule 3 (n_close_scope -> .)

    n_close_scope                  shift and go to state 121

state 118

    (67) condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope . condition_else
    (68) condition_else -> . ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (69) condition_else -> . empty
    (4) empty -> .

    ELSE            shift and go to state 123
    FUNCTION        reduce using rule 4 (empty -> .)
    IF              reduce using rule 4 (empty -> .)
    FOR             reduce using rule 4 (empty -> .)
    WHILE           reduce using rule 4 (empty -> .)
    NAME            reduce using rule 4 (empty -> .)
    INT_TYPE        reduce using rule 4 (empty -> .)
    STRING_TYPE     reduce using rule 4 (empty -> .)
    DOUBLE_TYPE     reduce using rule 4 (empty -> .)
    FLOAT_TYPE      reduce using rule 4 (empty -> .)
    BOOL_TYPE       reduce using rule 4 (empty -> .)
    $end            reduce using rule 4 (empty -> .)
    RCURLY          reduce using rule 4 (empty -> .)

    condition_else                 shift and go to state 122
    empty                          shift and go to state 124

state 119

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS . LCURLY codeblock RCURLY n_close_scope

    LCURLY          shift and go to state 125


state 120

    (65) whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .

    FUNCTION        reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    IF              reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    FOR             reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    WHILE           reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    NAME            reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    INT_TYPE        reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    STRING_TYPE     reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    DOUBLE_TYPE     reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    FLOAT_TYPE      reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    BOOL_TYPE       reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    $end            reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    RCURLY          reduce using rule 65 (whileloop -> WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)


state 121

    (29) function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .

    FUNCTION        reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    IF              reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    FOR             reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    WHILE           reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    NAME            reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    INT_TYPE        reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    STRING_TYPE     reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    DOUBLE_TYPE     reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    FLOAT_TYPE      reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    BOOL_TYPE       reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    $end            reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)
    RCURLY          reduce using rule 29 (function_definition -> FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope .)


state 122

    (67) condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .

    FUNCTION        reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    IF              reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    FOR             reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    WHILE           reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    NAME            reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    INT_TYPE        reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    STRING_TYPE     reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    DOUBLE_TYPE     reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    FLOAT_TYPE      reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    BOOL_TYPE       reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    $end            reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)
    RCURLY          reduce using rule 67 (condition_if -> IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else .)


state 123

    (68) condition_else -> ELSE . LCURLY n_open_new_scope codeblock RCURLY n_close_scope

    LCURLY          shift and go to state 126


state 124

    (69) condition_else -> empty .

    FUNCTION        reduce using rule 69 (condition_else -> empty .)
    IF              reduce using rule 69 (condition_else -> empty .)
    FOR             reduce using rule 69 (condition_else -> empty .)
    WHILE           reduce using rule 69 (condition_else -> empty .)
    NAME            reduce using rule 69 (condition_else -> empty .)
    INT_TYPE        reduce using rule 69 (condition_else -> empty .)
    STRING_TYPE     reduce using rule 69 (condition_else -> empty .)
    DOUBLE_TYPE     reduce using rule 69 (condition_else -> empty .)
    FLOAT_TYPE      reduce using rule 69 (condition_else -> empty .)
    BOOL_TYPE       reduce using rule 69 (condition_else -> empty .)
    $end            reduce using rule 69 (condition_else -> empty .)
    RCURLY          reduce using rule 69 (condition_else -> empty .)


state 125

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY . codeblock RCURLY n_close_scope
    (57) codeblock -> . empty
    (58) codeblock -> . codeblock_aux codeblock
    (4) empty -> .
    (59) codeblock_aux -> . statement
    (60) codeblock_aux -> . function_definition
    (61) codeblock_aux -> . condition_if
    (62) codeblock_aux -> . loop
    (54) statement -> . statement_aux SEMICOLON
    (29) function_definition -> . FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (67) condition_if -> . IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (63) loop -> . forloop
    (64) loop -> . whileloop
    (55) statement_aux -> . assign
    (56) statement_aux -> . function_call
    (66) forloop -> . FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (65) whileloop -> . WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    RCURLY          reduce using rule 4 (empty -> .)
    FUNCTION        shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    NAME            shift and go to state 14
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    assign                         shift and go to state 18
    codeblock                      shift and go to state 127
    empty                          shift and go to state 6
    codeblock_aux                  shift and go to state 7
    statement                      shift and go to state 8
    function_definition            shift and go to state 9
    condition_if                   shift and go to state 10
    loop                           shift and go to state 11
    statement_aux                  shift and go to state 12
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    function_call                  shift and go to state 19
    type                           shift and go to state 22

state 126

    (68) condition_else -> ELSE LCURLY . n_open_new_scope codeblock RCURLY n_close_scope
    (2) n_open_new_scope -> .

    FUNCTION        reduce using rule 2 (n_open_new_scope -> .)
    IF              reduce using rule 2 (n_open_new_scope -> .)
    FOR             reduce using rule 2 (n_open_new_scope -> .)
    WHILE           reduce using rule 2 (n_open_new_scope -> .)
    NAME            reduce using rule 2 (n_open_new_scope -> .)
    INT_TYPE        reduce using rule 2 (n_open_new_scope -> .)
    STRING_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    DOUBLE_TYPE     reduce using rule 2 (n_open_new_scope -> .)
    FLOAT_TYPE      reduce using rule 2 (n_open_new_scope -> .)
    BOOL_TYPE       reduce using rule 2 (n_open_new_scope -> .)
    RCURLY          reduce using rule 2 (n_open_new_scope -> .)

    n_open_new_scope               shift and go to state 128

state 127

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock . RCURLY n_close_scope

    RCURLY          shift and go to state 129


state 128

    (68) condition_else -> ELSE LCURLY n_open_new_scope . codeblock RCURLY n_close_scope
    (57) codeblock -> . empty
    (58) codeblock -> . codeblock_aux codeblock
    (4) empty -> .
    (59) codeblock_aux -> . statement
    (60) codeblock_aux -> . function_definition
    (61) codeblock_aux -> . condition_if
    (62) codeblock_aux -> . loop
    (54) statement -> . statement_aux SEMICOLON
    (29) function_definition -> . FUNCTION NAME n_open_new_scope parameter_list DOUBLEDOT function_type LCURLY codeblock RCURLY n_close_scope
    (67) condition_if -> . IF LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope condition_else
    (63) loop -> . forloop
    (64) loop -> . whileloop
    (55) statement_aux -> . assign
    (56) statement_aux -> . function_call
    (66) forloop -> . FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope
    (65) whileloop -> . WHILE LPARENTHESIS expression RPARENTHESIS LCURLY n_open_new_scope codeblock RCURLY n_close_scope
    (51) assign -> . type NAME n_name_assign EQUAL expression
    (52) assign -> . NAME n_name_assign EQUAL expression
    (30) function_call -> . NAME LPARENTHESIS parameter_list RPARENTHESIS
    (8) type -> . INT_TYPE n_seen_type
    (9) type -> . STRING_TYPE n_seen_type
    (10) type -> . DOUBLE_TYPE n_seen_type
    (11) type -> . FLOAT_TYPE n_seen_type
    (12) type -> . BOOL_TYPE n_seen_type

    RCURLY          reduce using rule 4 (empty -> .)
    FUNCTION        shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    NAME            shift and go to state 14
    INT_TYPE        shift and go to state 23
    STRING_TYPE     shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    FLOAT_TYPE      shift and go to state 26
    BOOL_TYPE       shift and go to state 27

    codeblock                      shift and go to state 130
    empty                          shift and go to state 6
    codeblock_aux                  shift and go to state 7
    statement                      shift and go to state 8
    function_definition            shift and go to state 9
    condition_if                   shift and go to state 10
    loop                           shift and go to state 11
    statement_aux                  shift and go to state 12
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assign                         shift and go to state 18
    function_call                  shift and go to state 19
    type                           shift and go to state 22

state 129

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY . n_close_scope
    (3) n_close_scope -> .

    FUNCTION        reduce using rule 3 (n_close_scope -> .)
    IF              reduce using rule 3 (n_close_scope -> .)
    FOR             reduce using rule 3 (n_close_scope -> .)
    WHILE           reduce using rule 3 (n_close_scope -> .)
    NAME            reduce using rule 3 (n_close_scope -> .)
    INT_TYPE        reduce using rule 3 (n_close_scope -> .)
    STRING_TYPE     reduce using rule 3 (n_close_scope -> .)
    DOUBLE_TYPE     reduce using rule 3 (n_close_scope -> .)
    FLOAT_TYPE      reduce using rule 3 (n_close_scope -> .)
    BOOL_TYPE       reduce using rule 3 (n_close_scope -> .)
    $end            reduce using rule 3 (n_close_scope -> .)
    RCURLY          reduce using rule 3 (n_close_scope -> .)

    n_close_scope                  shift and go to state 131

state 130

    (68) condition_else -> ELSE LCURLY n_open_new_scope codeblock . RCURLY n_close_scope

    RCURLY          shift and go to state 132


state 131

    (66) forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .

    FUNCTION        reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    IF              reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    FOR             reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    WHILE           reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    NAME            reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    INT_TYPE        reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    STRING_TYPE     reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    DOUBLE_TYPE     reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    FLOAT_TYPE      reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    BOOL_TYPE       reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    $end            reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)
    RCURLY          reduce using rule 66 (forloop -> FOR LPARENTHESIS n_open_new_scope assign DOUBLEDOT expression DOUBLEDOT assign RPARENTHESIS LCURLY codeblock RCURLY n_close_scope .)


state 132

    (68) condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY . n_close_scope
    (3) n_close_scope -> .

    FUNCTION        reduce using rule 3 (n_close_scope -> .)
    IF              reduce using rule 3 (n_close_scope -> .)
    FOR             reduce using rule 3 (n_close_scope -> .)
    WHILE           reduce using rule 3 (n_close_scope -> .)
    NAME            reduce using rule 3 (n_close_scope -> .)
    INT_TYPE        reduce using rule 3 (n_close_scope -> .)
    STRING_TYPE     reduce using rule 3 (n_close_scope -> .)
    DOUBLE_TYPE     reduce using rule 3 (n_close_scope -> .)
    FLOAT_TYPE      reduce using rule 3 (n_close_scope -> .)
    BOOL_TYPE       reduce using rule 3 (n_close_scope -> .)
    $end            reduce using rule 3 (n_close_scope -> .)
    RCURLY          reduce using rule 3 (n_close_scope -> .)

    n_close_scope                  shift and go to state 133

state 133

    (68) condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .

    FUNCTION        reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    IF              reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    FOR             reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    WHILE           reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    NAME            reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    INT_TYPE        reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    STRING_TYPE     reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    DOUBLE_TYPE     reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    FLOAT_TYPE      reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    BOOL_TYPE       reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    $end            reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)
    RCURLY          reduce using rule 68 (condition_else -> ELSE LCURLY n_open_new_scope codeblock RCURLY n_close_scope .)

